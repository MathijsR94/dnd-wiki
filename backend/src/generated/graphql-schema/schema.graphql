type Ability {
  id: ID!
  type: ABILITY_TYPE!
  value: Int!
  modifier: Int!
  character: Character!
}

enum ABILITY_TYPE {
  STR
  DEX
  CON
  INT
  WIS
  CHA
}

type AbilityConnection {
  pageInfo: PageInfo!
  edges: [AbilityEdge]!
  aggregate: AggregateAbility!
}

input AbilityCreateInput {
  id: ID
  type: ABILITY_TYPE!
  value: Int!
  modifier: Int!
  character: CharacterCreateOneInput!
}

input AbilityCreateManyInput {
  create: [AbilityCreateInput!]
  connect: [AbilityWhereUniqueInput!]
}

type AbilityEdge {
  node: Ability!
  cursor: String!
}

enum AbilityOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  value_ASC
  value_DESC
  modifier_ASC
  modifier_DESC
}

type AbilityPreviousValues {
  id: ID!
  type: ABILITY_TYPE!
  value: Int!
  modifier: Int!
}

input AbilityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ABILITY_TYPE
  type_not: ABILITY_TYPE
  type_in: [ABILITY_TYPE!]
  type_not_in: [ABILITY_TYPE!]
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  modifier: Int
  modifier_not: Int
  modifier_in: [Int!]
  modifier_not_in: [Int!]
  modifier_lt: Int
  modifier_lte: Int
  modifier_gt: Int
  modifier_gte: Int
  AND: [AbilityScalarWhereInput!]
  OR: [AbilityScalarWhereInput!]
  NOT: [AbilityScalarWhereInput!]
}

type AbilitySubscriptionPayload {
  mutation: MutationType!
  node: Ability
  updatedFields: [String!]
  previousValues: AbilityPreviousValues
}

input AbilitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AbilityWhereInput
  AND: [AbilitySubscriptionWhereInput!]
  OR: [AbilitySubscriptionWhereInput!]
  NOT: [AbilitySubscriptionWhereInput!]
}

input AbilityUpdateDataInput {
  type: ABILITY_TYPE
  value: Int
  modifier: Int
  character: CharacterUpdateOneRequiredInput
}

input AbilityUpdateInput {
  type: ABILITY_TYPE
  value: Int
  modifier: Int
  character: CharacterUpdateOneRequiredInput
}

input AbilityUpdateManyDataInput {
  type: ABILITY_TYPE
  value: Int
  modifier: Int
}

input AbilityUpdateManyInput {
  create: [AbilityCreateInput!]
  update: [AbilityUpdateWithWhereUniqueNestedInput!]
  upsert: [AbilityUpsertWithWhereUniqueNestedInput!]
  delete: [AbilityWhereUniqueInput!]
  connect: [AbilityWhereUniqueInput!]
  set: [AbilityWhereUniqueInput!]
  disconnect: [AbilityWhereUniqueInput!]
  deleteMany: [AbilityScalarWhereInput!]
  updateMany: [AbilityUpdateManyWithWhereNestedInput!]
}

input AbilityUpdateManyMutationInput {
  type: ABILITY_TYPE
  value: Int
  modifier: Int
}

input AbilityUpdateManyWithWhereNestedInput {
  where: AbilityScalarWhereInput!
  data: AbilityUpdateManyDataInput!
}

input AbilityUpdateWithWhereUniqueNestedInput {
  where: AbilityWhereUniqueInput!
  data: AbilityUpdateDataInput!
}

input AbilityUpsertWithWhereUniqueNestedInput {
  where: AbilityWhereUniqueInput!
  update: AbilityUpdateDataInput!
  create: AbilityCreateInput!
}

input AbilityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ABILITY_TYPE
  type_not: ABILITY_TYPE
  type_in: [ABILITY_TYPE!]
  type_not_in: [ABILITY_TYPE!]
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  modifier: Int
  modifier_not: Int
  modifier_in: [Int!]
  modifier_not_in: [Int!]
  modifier_lt: Int
  modifier_lte: Int
  modifier_gt: Int
  modifier_gte: Int
  character: CharacterWhereInput
  AND: [AbilityWhereInput!]
  OR: [AbilityWhereInput!]
  NOT: [AbilityWhereInput!]
}

input AbilityWhereUniqueInput {
  id: ID
}

type AggregateAbility {
  count: Int!
}

type AggregateCampaign {
  count: Int!
}

type AggregateCharacter {
  count: Int!
}

type AggregateCharacterMetadata {
  count: Int!
}

type AggregateCurrency {
  count: Int!
}

type AggregateEconomy {
  count: Int!
}

type AggregateEtnicity {
  count: Int!
}

type AggregateFlag {
  count: Int!
}

type AggregateGovernment {
  count: Int!
}

type AggregateGovernmentParty {
  count: Int!
}

type AggregateHTMLContent {
  count: Int!
}

type AggregateLanguage {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateLocationMetaData {
  count: Int!
}

type AggregatePopulation {
  count: Int!
}

type AggregateReligion {
  count: Int!
}

type AggregateSkill {
  count: Int!
}

type AggregateUser {
  count: Int!
}

enum ALIGNMENT {
  LG
  NG
  CG
  LN
  TN
  CN
  LE
  NE
  CE
}

type BatchPayload {
  count: Long!
}

type Campaign {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
  players(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Character!]
}

type CampaignConnection {
  pageInfo: PageInfo!
  edges: [CampaignEdge]!
  aggregate: AggregateCampaign!
}

input CampaignCreateInput {
  id: ID
  name: String!
  locations: LocationCreateManyWithoutCampaignInput
  players: CharacterCreateManyWithoutCampaignInput
}

input CampaignCreateManyInput {
  create: [CampaignCreateInput!]
  connect: [CampaignWhereUniqueInput!]
}

input CampaignCreateOneWithoutLocationsInput {
  create: CampaignCreateWithoutLocationsInput
  connect: CampaignWhereUniqueInput
}

input CampaignCreateOneWithoutPlayersInput {
  create: CampaignCreateWithoutPlayersInput
  connect: CampaignWhereUniqueInput
}

input CampaignCreateWithoutLocationsInput {
  id: ID
  name: String!
  players: CharacterCreateManyWithoutCampaignInput
}

input CampaignCreateWithoutPlayersInput {
  id: ID
  name: String!
  locations: LocationCreateManyWithoutCampaignInput
}

type CampaignEdge {
  node: Campaign!
  cursor: String!
}

enum CampaignOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CampaignPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CampaignScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CampaignScalarWhereInput!]
  OR: [CampaignScalarWhereInput!]
  NOT: [CampaignScalarWhereInput!]
}

type CampaignSubscriptionPayload {
  mutation: MutationType!
  node: Campaign
  updatedFields: [String!]
  previousValues: CampaignPreviousValues
}

input CampaignSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CampaignWhereInput
  AND: [CampaignSubscriptionWhereInput!]
  OR: [CampaignSubscriptionWhereInput!]
  NOT: [CampaignSubscriptionWhereInput!]
}

input CampaignUpdateDataInput {
  name: String
  locations: LocationUpdateManyWithoutCampaignInput
  players: CharacterUpdateManyWithoutCampaignInput
}

input CampaignUpdateInput {
  name: String
  locations: LocationUpdateManyWithoutCampaignInput
  players: CharacterUpdateManyWithoutCampaignInput
}

input CampaignUpdateManyDataInput {
  name: String
}

input CampaignUpdateManyInput {
  create: [CampaignCreateInput!]
  update: [CampaignUpdateWithWhereUniqueNestedInput!]
  upsert: [CampaignUpsertWithWhereUniqueNestedInput!]
  delete: [CampaignWhereUniqueInput!]
  connect: [CampaignWhereUniqueInput!]
  set: [CampaignWhereUniqueInput!]
  disconnect: [CampaignWhereUniqueInput!]
  deleteMany: [CampaignScalarWhereInput!]
  updateMany: [CampaignUpdateManyWithWhereNestedInput!]
}

input CampaignUpdateManyMutationInput {
  name: String
}

input CampaignUpdateManyWithWhereNestedInput {
  where: CampaignScalarWhereInput!
  data: CampaignUpdateManyDataInput!
}

input CampaignUpdateOneRequiredWithoutLocationsInput {
  create: CampaignCreateWithoutLocationsInput
  update: CampaignUpdateWithoutLocationsDataInput
  upsert: CampaignUpsertWithoutLocationsInput
  connect: CampaignWhereUniqueInput
}

input CampaignUpdateOneRequiredWithoutPlayersInput {
  create: CampaignCreateWithoutPlayersInput
  update: CampaignUpdateWithoutPlayersDataInput
  upsert: CampaignUpsertWithoutPlayersInput
  connect: CampaignWhereUniqueInput
}

input CampaignUpdateWithoutLocationsDataInput {
  name: String
  players: CharacterUpdateManyWithoutCampaignInput
}

input CampaignUpdateWithoutPlayersDataInput {
  name: String
  locations: LocationUpdateManyWithoutCampaignInput
}

input CampaignUpdateWithWhereUniqueNestedInput {
  where: CampaignWhereUniqueInput!
  data: CampaignUpdateDataInput!
}

input CampaignUpsertWithoutLocationsInput {
  update: CampaignUpdateWithoutLocationsDataInput!
  create: CampaignCreateWithoutLocationsInput!
}

input CampaignUpsertWithoutPlayersInput {
  update: CampaignUpdateWithoutPlayersDataInput!
  create: CampaignCreateWithoutPlayersInput!
}

input CampaignUpsertWithWhereUniqueNestedInput {
  where: CampaignWhereUniqueInput!
  update: CampaignUpdateDataInput!
  create: CampaignCreateInput!
}

input CampaignWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  locations_every: LocationWhereInput
  locations_some: LocationWhereInput
  locations_none: LocationWhereInput
  players_every: CharacterWhereInput
  players_some: CharacterWhereInput
  players_none: CharacterWhereInput
  AND: [CampaignWhereInput!]
  OR: [CampaignWhereInput!]
  NOT: [CampaignWhereInput!]
}

input CampaignWhereUniqueInput {
  id: ID
}

type Character {
  id: ID!
  firstName: String!
  lastName: String
  type: CHARACTER_TYPE!
  metadata: CharacterMetadata
  campaign: Campaign!
}

enum CHARACTER_STATUS {
  ALIVE
  DEAD
}

enum CHARACTER_TYPE {
  PC
  NPC
}

type CharacterConnection {
  pageInfo: PageInfo!
  edges: [CharacterEdge]!
  aggregate: AggregateCharacter!
}

input CharacterCreateInput {
  id: ID
  firstName: String!
  lastName: String
  type: CHARACTER_TYPE!
  metadata: CharacterMetadataCreateOneWithoutCharacterInput
  campaign: CampaignCreateOneWithoutPlayersInput!
}

input CharacterCreateManyInput {
  create: [CharacterCreateInput!]
  connect: [CharacterWhereUniqueInput!]
}

input CharacterCreateManyWithoutCampaignInput {
  create: [CharacterCreateWithoutCampaignInput!]
  connect: [CharacterWhereUniqueInput!]
}

input CharacterCreateOneInput {
  create: CharacterCreateInput
  connect: CharacterWhereUniqueInput
}

input CharacterCreateOneWithoutMetadataInput {
  create: CharacterCreateWithoutMetadataInput
  connect: CharacterWhereUniqueInput
}

input CharacterCreateWithoutCampaignInput {
  id: ID
  firstName: String!
  lastName: String
  type: CHARACTER_TYPE!
  metadata: CharacterMetadataCreateOneWithoutCharacterInput
}

input CharacterCreateWithoutMetadataInput {
  id: ID
  firstName: String!
  lastName: String
  type: CHARACTER_TYPE!
  campaign: CampaignCreateOneWithoutPlayersInput!
}

type CharacterEdge {
  node: Character!
  cursor: String!
}

type CharacterMetadata {
  id: ID!
  character: Character!
  abilities(where: AbilityWhereInput, orderBy: AbilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ability!]
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

type CharacterMetadataConnection {
  pageInfo: PageInfo!
  edges: [CharacterMetadataEdge]!
  aggregate: AggregateCharacterMetadata!
}

input CharacterMetadataCreateInput {
  id: ID
  character: CharacterCreateOneWithoutMetadataInput!
  abilities: AbilityCreateManyInput
  skills: SkillCreateManyInput
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

input CharacterMetadataCreateOneWithoutCharacterInput {
  create: CharacterMetadataCreateWithoutCharacterInput
  connect: CharacterMetadataWhereUniqueInput
}

input CharacterMetadataCreateWithoutCharacterInput {
  id: ID
  abilities: AbilityCreateManyInput
  skills: SkillCreateManyInput
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

type CharacterMetadataEdge {
  node: CharacterMetadata!
  cursor: String!
}

enum CharacterMetadataOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  race_ASC
  race_DESC
  class_ASC
  class_DESC
  alignment_ASC
  alignment_DESC
  height_ASC
  height_DESC
  weight_ASC
  weight_DESC
}

type CharacterMetadataPreviousValues {
  id: ID!
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

type CharacterMetadataSubscriptionPayload {
  mutation: MutationType!
  node: CharacterMetadata
  updatedFields: [String!]
  previousValues: CharacterMetadataPreviousValues
}

input CharacterMetadataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CharacterMetadataWhereInput
  AND: [CharacterMetadataSubscriptionWhereInput!]
  OR: [CharacterMetadataSubscriptionWhereInput!]
  NOT: [CharacterMetadataSubscriptionWhereInput!]
}

input CharacterMetadataUpdateInput {
  character: CharacterUpdateOneRequiredWithoutMetadataInput
  abilities: AbilityUpdateManyInput
  skills: SkillUpdateManyInput
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

input CharacterMetadataUpdateManyMutationInput {
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

input CharacterMetadataUpdateOneWithoutCharacterInput {
  create: CharacterMetadataCreateWithoutCharacterInput
  update: CharacterMetadataUpdateWithoutCharacterDataInput
  upsert: CharacterMetadataUpsertWithoutCharacterInput
  delete: Boolean
  disconnect: Boolean
  connect: CharacterMetadataWhereUniqueInput
}

input CharacterMetadataUpdateWithoutCharacterDataInput {
  abilities: AbilityUpdateManyInput
  skills: SkillUpdateManyInput
  status: CHARACTER_STATUS
  race: RACE
  class: CLASS
  alignment: ALIGNMENT
  height: Int
  weight: Int
}

input CharacterMetadataUpsertWithoutCharacterInput {
  update: CharacterMetadataUpdateWithoutCharacterDataInput!
  create: CharacterMetadataCreateWithoutCharacterInput!
}

input CharacterMetadataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: CharacterWhereInput
  abilities_every: AbilityWhereInput
  abilities_some: AbilityWhereInput
  abilities_none: AbilityWhereInput
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  status: CHARACTER_STATUS
  status_not: CHARACTER_STATUS
  status_in: [CHARACTER_STATUS!]
  status_not_in: [CHARACTER_STATUS!]
  race: RACE
  race_not: RACE
  race_in: [RACE!]
  race_not_in: [RACE!]
  class: CLASS
  class_not: CLASS
  class_in: [CLASS!]
  class_not_in: [CLASS!]
  alignment: ALIGNMENT
  alignment_not: ALIGNMENT
  alignment_in: [ALIGNMENT!]
  alignment_not_in: [ALIGNMENT!]
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  AND: [CharacterMetadataWhereInput!]
  OR: [CharacterMetadataWhereInput!]
  NOT: [CharacterMetadataWhereInput!]
}

input CharacterMetadataWhereUniqueInput {
  id: ID
}

enum CharacterOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  type_ASC
  type_DESC
}

type CharacterPreviousValues {
  id: ID!
  firstName: String!
  lastName: String
  type: CHARACTER_TYPE!
}

input CharacterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  type: CHARACTER_TYPE
  type_not: CHARACTER_TYPE
  type_in: [CHARACTER_TYPE!]
  type_not_in: [CHARACTER_TYPE!]
  AND: [CharacterScalarWhereInput!]
  OR: [CharacterScalarWhereInput!]
  NOT: [CharacterScalarWhereInput!]
}

type CharacterSubscriptionPayload {
  mutation: MutationType!
  node: Character
  updatedFields: [String!]
  previousValues: CharacterPreviousValues
}

input CharacterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CharacterWhereInput
  AND: [CharacterSubscriptionWhereInput!]
  OR: [CharacterSubscriptionWhereInput!]
  NOT: [CharacterSubscriptionWhereInput!]
}

input CharacterUpdateDataInput {
  firstName: String
  lastName: String
  type: CHARACTER_TYPE
  metadata: CharacterMetadataUpdateOneWithoutCharacterInput
  campaign: CampaignUpdateOneRequiredWithoutPlayersInput
}

input CharacterUpdateInput {
  firstName: String
  lastName: String
  type: CHARACTER_TYPE
  metadata: CharacterMetadataUpdateOneWithoutCharacterInput
  campaign: CampaignUpdateOneRequiredWithoutPlayersInput
}

input CharacterUpdateManyDataInput {
  firstName: String
  lastName: String
  type: CHARACTER_TYPE
}

input CharacterUpdateManyInput {
  create: [CharacterCreateInput!]
  update: [CharacterUpdateWithWhereUniqueNestedInput!]
  upsert: [CharacterUpsertWithWhereUniqueNestedInput!]
  delete: [CharacterWhereUniqueInput!]
  connect: [CharacterWhereUniqueInput!]
  set: [CharacterWhereUniqueInput!]
  disconnect: [CharacterWhereUniqueInput!]
  deleteMany: [CharacterScalarWhereInput!]
  updateMany: [CharacterUpdateManyWithWhereNestedInput!]
}

input CharacterUpdateManyMutationInput {
  firstName: String
  lastName: String
  type: CHARACTER_TYPE
}

input CharacterUpdateManyWithoutCampaignInput {
  create: [CharacterCreateWithoutCampaignInput!]
  delete: [CharacterWhereUniqueInput!]
  connect: [CharacterWhereUniqueInput!]
  set: [CharacterWhereUniqueInput!]
  disconnect: [CharacterWhereUniqueInput!]
  update: [CharacterUpdateWithWhereUniqueWithoutCampaignInput!]
  upsert: [CharacterUpsertWithWhereUniqueWithoutCampaignInput!]
  deleteMany: [CharacterScalarWhereInput!]
  updateMany: [CharacterUpdateManyWithWhereNestedInput!]
}

input CharacterUpdateManyWithWhereNestedInput {
  where: CharacterScalarWhereInput!
  data: CharacterUpdateManyDataInput!
}

input CharacterUpdateOneInput {
  create: CharacterCreateInput
  update: CharacterUpdateDataInput
  upsert: CharacterUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CharacterWhereUniqueInput
}

input CharacterUpdateOneRequiredInput {
  create: CharacterCreateInput
  update: CharacterUpdateDataInput
  upsert: CharacterUpsertNestedInput
  connect: CharacterWhereUniqueInput
}

input CharacterUpdateOneRequiredWithoutMetadataInput {
  create: CharacterCreateWithoutMetadataInput
  update: CharacterUpdateWithoutMetadataDataInput
  upsert: CharacterUpsertWithoutMetadataInput
  connect: CharacterWhereUniqueInput
}

input CharacterUpdateWithoutCampaignDataInput {
  firstName: String
  lastName: String
  type: CHARACTER_TYPE
  metadata: CharacterMetadataUpdateOneWithoutCharacterInput
}

input CharacterUpdateWithoutMetadataDataInput {
  firstName: String
  lastName: String
  type: CHARACTER_TYPE
  campaign: CampaignUpdateOneRequiredWithoutPlayersInput
}

input CharacterUpdateWithWhereUniqueNestedInput {
  where: CharacterWhereUniqueInput!
  data: CharacterUpdateDataInput!
}

input CharacterUpdateWithWhereUniqueWithoutCampaignInput {
  where: CharacterWhereUniqueInput!
  data: CharacterUpdateWithoutCampaignDataInput!
}

input CharacterUpsertNestedInput {
  update: CharacterUpdateDataInput!
  create: CharacterCreateInput!
}

input CharacterUpsertWithoutMetadataInput {
  update: CharacterUpdateWithoutMetadataDataInput!
  create: CharacterCreateWithoutMetadataInput!
}

input CharacterUpsertWithWhereUniqueNestedInput {
  where: CharacterWhereUniqueInput!
  update: CharacterUpdateDataInput!
  create: CharacterCreateInput!
}

input CharacterUpsertWithWhereUniqueWithoutCampaignInput {
  where: CharacterWhereUniqueInput!
  update: CharacterUpdateWithoutCampaignDataInput!
  create: CharacterCreateWithoutCampaignInput!
}

input CharacterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  type: CHARACTER_TYPE
  type_not: CHARACTER_TYPE
  type_in: [CHARACTER_TYPE!]
  type_not_in: [CHARACTER_TYPE!]
  metadata: CharacterMetadataWhereInput
  campaign: CampaignWhereInput
  AND: [CharacterWhereInput!]
  OR: [CharacterWhereInput!]
  NOT: [CharacterWhereInput!]
}

input CharacterWhereUniqueInput {
  id: ID
}

enum CLASS {
  Barbarian
  Bard
  Cleric
  Druid
  Fighter
  Monk
  Paladin
  Ranger
  Rogue
  Sorcerer
  Warlock
  Wizard
}

enum CLIMATE {
  Tropical
  Dry
  Mild
  Continental
  Polar
}

type Currency {
  id: ID!
  name: String!
  sign: String
}

type CurrencyConnection {
  pageInfo: PageInfo!
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  id: ID
  name: String!
  sign: String
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

type CurrencyEdge {
  node: Currency!
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  sign_ASC
  sign_DESC
}

type CurrencyPreviousValues {
  id: ID!
  name: String!
  sign: String
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
  AND: [CurrencySubscriptionWhereInput!]
  OR: [CurrencySubscriptionWhereInput!]
  NOT: [CurrencySubscriptionWhereInput!]
}

input CurrencyUpdateDataInput {
  name: String
  sign: String
}

input CurrencyUpdateInput {
  name: String
  sign: String
}

input CurrencyUpdateManyMutationInput {
  name: String
  sign: String
}

input CurrencyUpdateOneInput {
  create: CurrencyCreateInput
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CurrencyWhereUniqueInput
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  sign: String
  sign_not: String
  sign_in: [String!]
  sign_not_in: [String!]
  sign_lt: String
  sign_lte: String
  sign_gt: String
  sign_gte: String
  sign_contains: String
  sign_not_contains: String
  sign_starts_with: String
  sign_not_starts_with: String
  sign_ends_with: String
  sign_not_ends_with: String
  AND: [CurrencyWhereInput!]
  OR: [CurrencyWhereInput!]
  NOT: [CurrencyWhereInput!]
}

input CurrencyWhereUniqueInput {
  id: ID
}

scalar DateTime

enum DENSITY_UNIT {
  SqKm
  Custom
}

type Economy {
  id: ID!
  currency: Currency
  location(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
}

type EconomyConnection {
  pageInfo: PageInfo!
  edges: [EconomyEdge]!
  aggregate: AggregateEconomy!
}

input EconomyCreateInput {
  id: ID
  currency: CurrencyCreateOneInput
  location: LocationCreateManyInput
}

input EconomyCreateOneInput {
  create: EconomyCreateInput
  connect: EconomyWhereUniqueInput
}

type EconomyEdge {
  node: Economy!
  cursor: String!
}

enum EconomyOrderByInput {
  id_ASC
  id_DESC
}

type EconomyPreviousValues {
  id: ID!
}

type EconomySubscriptionPayload {
  mutation: MutationType!
  node: Economy
  updatedFields: [String!]
  previousValues: EconomyPreviousValues
}

input EconomySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EconomyWhereInput
  AND: [EconomySubscriptionWhereInput!]
  OR: [EconomySubscriptionWhereInput!]
  NOT: [EconomySubscriptionWhereInput!]
}

input EconomyUpdateDataInput {
  currency: CurrencyUpdateOneInput
  location: LocationUpdateManyInput
}

input EconomyUpdateInput {
  currency: CurrencyUpdateOneInput
  location: LocationUpdateManyInput
}

input EconomyUpdateOneInput {
  create: EconomyCreateInput
  update: EconomyUpdateDataInput
  upsert: EconomyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: EconomyWhereUniqueInput
}

input EconomyUpsertNestedInput {
  update: EconomyUpdateDataInput!
  create: EconomyCreateInput!
}

input EconomyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currency: CurrencyWhereInput
  location_every: LocationWhereInput
  location_some: LocationWhereInput
  location_none: LocationWhereInput
  AND: [EconomyWhereInput!]
  OR: [EconomyWhereInput!]
  NOT: [EconomyWhereInput!]
}

input EconomyWhereUniqueInput {
  id: ID
}

type Etnicity {
  id: ID!
  name: String!
}

type EtnicityConnection {
  pageInfo: PageInfo!
  edges: [EtnicityEdge]!
  aggregate: AggregateEtnicity!
}

input EtnicityCreateInput {
  id: ID
  name: String!
}

input EtnicityCreateManyInput {
  create: [EtnicityCreateInput!]
  connect: [EtnicityWhereUniqueInput!]
}

type EtnicityEdge {
  node: Etnicity!
  cursor: String!
}

enum EtnicityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type EtnicityPreviousValues {
  id: ID!
  name: String!
}

input EtnicityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [EtnicityScalarWhereInput!]
  OR: [EtnicityScalarWhereInput!]
  NOT: [EtnicityScalarWhereInput!]
}

type EtnicitySubscriptionPayload {
  mutation: MutationType!
  node: Etnicity
  updatedFields: [String!]
  previousValues: EtnicityPreviousValues
}

input EtnicitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EtnicityWhereInput
  AND: [EtnicitySubscriptionWhereInput!]
  OR: [EtnicitySubscriptionWhereInput!]
  NOT: [EtnicitySubscriptionWhereInput!]
}

input EtnicityUpdateDataInput {
  name: String
}

input EtnicityUpdateInput {
  name: String
}

input EtnicityUpdateManyDataInput {
  name: String
}

input EtnicityUpdateManyInput {
  create: [EtnicityCreateInput!]
  update: [EtnicityUpdateWithWhereUniqueNestedInput!]
  upsert: [EtnicityUpsertWithWhereUniqueNestedInput!]
  delete: [EtnicityWhereUniqueInput!]
  connect: [EtnicityWhereUniqueInput!]
  set: [EtnicityWhereUniqueInput!]
  disconnect: [EtnicityWhereUniqueInput!]
  deleteMany: [EtnicityScalarWhereInput!]
  updateMany: [EtnicityUpdateManyWithWhereNestedInput!]
}

input EtnicityUpdateManyMutationInput {
  name: String
}

input EtnicityUpdateManyWithWhereNestedInput {
  where: EtnicityScalarWhereInput!
  data: EtnicityUpdateManyDataInput!
}

input EtnicityUpdateWithWhereUniqueNestedInput {
  where: EtnicityWhereUniqueInput!
  data: EtnicityUpdateDataInput!
}

input EtnicityUpsertWithWhereUniqueNestedInput {
  where: EtnicityWhereUniqueInput!
  update: EtnicityUpdateDataInput!
  create: EtnicityCreateInput!
}

input EtnicityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [EtnicityWhereInput!]
  OR: [EtnicityWhereInput!]
  NOT: [EtnicityWhereInput!]
}

input EtnicityWhereUniqueInput {
  id: ID
}

type Flag {
  id: ID!
  imageSrc: String
  description: String!
  location: Location
}

type FlagConnection {
  pageInfo: PageInfo!
  edges: [FlagEdge]!
  aggregate: AggregateFlag!
}

input FlagCreateInput {
  id: ID
  imageSrc: String
  description: String!
  location: LocationCreateOneInput
}

input FlagCreateManyInput {
  create: [FlagCreateInput!]
  connect: [FlagWhereUniqueInput!]
}

type FlagEdge {
  node: Flag!
  cursor: String!
}

enum FlagOrderByInput {
  id_ASC
  id_DESC
  imageSrc_ASC
  imageSrc_DESC
  description_ASC
  description_DESC
}

type FlagPreviousValues {
  id: ID!
  imageSrc: String
  description: String!
}

input FlagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  imageSrc: String
  imageSrc_not: String
  imageSrc_in: [String!]
  imageSrc_not_in: [String!]
  imageSrc_lt: String
  imageSrc_lte: String
  imageSrc_gt: String
  imageSrc_gte: String
  imageSrc_contains: String
  imageSrc_not_contains: String
  imageSrc_starts_with: String
  imageSrc_not_starts_with: String
  imageSrc_ends_with: String
  imageSrc_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [FlagScalarWhereInput!]
  OR: [FlagScalarWhereInput!]
  NOT: [FlagScalarWhereInput!]
}

type FlagSubscriptionPayload {
  mutation: MutationType!
  node: Flag
  updatedFields: [String!]
  previousValues: FlagPreviousValues
}

input FlagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FlagWhereInput
  AND: [FlagSubscriptionWhereInput!]
  OR: [FlagSubscriptionWhereInput!]
  NOT: [FlagSubscriptionWhereInput!]
}

input FlagUpdateDataInput {
  imageSrc: String
  description: String
  location: LocationUpdateOneInput
}

input FlagUpdateInput {
  imageSrc: String
  description: String
  location: LocationUpdateOneInput
}

input FlagUpdateManyDataInput {
  imageSrc: String
  description: String
}

input FlagUpdateManyInput {
  create: [FlagCreateInput!]
  update: [FlagUpdateWithWhereUniqueNestedInput!]
  upsert: [FlagUpsertWithWhereUniqueNestedInput!]
  delete: [FlagWhereUniqueInput!]
  connect: [FlagWhereUniqueInput!]
  set: [FlagWhereUniqueInput!]
  disconnect: [FlagWhereUniqueInput!]
  deleteMany: [FlagScalarWhereInput!]
  updateMany: [FlagUpdateManyWithWhereNestedInput!]
}

input FlagUpdateManyMutationInput {
  imageSrc: String
  description: String
}

input FlagUpdateManyWithWhereNestedInput {
  where: FlagScalarWhereInput!
  data: FlagUpdateManyDataInput!
}

input FlagUpdateWithWhereUniqueNestedInput {
  where: FlagWhereUniqueInput!
  data: FlagUpdateDataInput!
}

input FlagUpsertWithWhereUniqueNestedInput {
  where: FlagWhereUniqueInput!
  update: FlagUpdateDataInput!
  create: FlagCreateInput!
}

input FlagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  imageSrc: String
  imageSrc_not: String
  imageSrc_in: [String!]
  imageSrc_not_in: [String!]
  imageSrc_lt: String
  imageSrc_lte: String
  imageSrc_gt: String
  imageSrc_gte: String
  imageSrc_contains: String
  imageSrc_not_contains: String
  imageSrc_starts_with: String
  imageSrc_not_starts_with: String
  imageSrc_ends_with: String
  imageSrc_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  location: LocationWhereInput
  AND: [FlagWhereInput!]
  OR: [FlagWhereInput!]
  NOT: [FlagWhereInput!]
}

input FlagWhereUniqueInput {
  id: ID
}

type Government {
  id: ID!
  leader: Character
  parties(where: GovernmentPartyWhereInput, orderBy: GovernmentPartyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GovernmentParty!]
  content(where: HTMLContentWhereInput, orderBy: HTMLContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HTMLContent!]
}

type GovernmentConnection {
  pageInfo: PageInfo!
  edges: [GovernmentEdge]!
  aggregate: AggregateGovernment!
}

input GovernmentCreateInput {
  id: ID
  leader: CharacterCreateOneInput
  parties: GovernmentPartyCreateManyWithoutGovernmentInput
  content: HTMLContentCreateManyInput
}

input GovernmentCreateOneInput {
  create: GovernmentCreateInput
  connect: GovernmentWhereUniqueInput
}

input GovernmentCreateOneWithoutPartiesInput {
  create: GovernmentCreateWithoutPartiesInput
  connect: GovernmentWhereUniqueInput
}

input GovernmentCreateWithoutPartiesInput {
  id: ID
  leader: CharacterCreateOneInput
  content: HTMLContentCreateManyInput
}

type GovernmentEdge {
  node: Government!
  cursor: String!
}

enum GovernmentOrderByInput {
  id_ASC
  id_DESC
}

type GovernmentParty {
  id: ID!
  leader: Character
  name: String!
  content(where: HTMLContentWhereInput, orderBy: HTMLContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HTMLContent!]
  government: Government
}

type GovernmentPartyConnection {
  pageInfo: PageInfo!
  edges: [GovernmentPartyEdge]!
  aggregate: AggregateGovernmentParty!
}

input GovernmentPartyCreateInput {
  id: ID
  leader: CharacterCreateOneInput
  name: String!
  content: HTMLContentCreateManyInput
  government: GovernmentCreateOneWithoutPartiesInput
}

input GovernmentPartyCreateManyWithoutGovernmentInput {
  create: [GovernmentPartyCreateWithoutGovernmentInput!]
  connect: [GovernmentPartyWhereUniqueInput!]
}

input GovernmentPartyCreateWithoutGovernmentInput {
  id: ID
  leader: CharacterCreateOneInput
  name: String!
  content: HTMLContentCreateManyInput
}

type GovernmentPartyEdge {
  node: GovernmentParty!
  cursor: String!
}

enum GovernmentPartyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type GovernmentPartyPreviousValues {
  id: ID!
  name: String!
}

input GovernmentPartyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GovernmentPartyScalarWhereInput!]
  OR: [GovernmentPartyScalarWhereInput!]
  NOT: [GovernmentPartyScalarWhereInput!]
}

type GovernmentPartySubscriptionPayload {
  mutation: MutationType!
  node: GovernmentParty
  updatedFields: [String!]
  previousValues: GovernmentPartyPreviousValues
}

input GovernmentPartySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GovernmentPartyWhereInput
  AND: [GovernmentPartySubscriptionWhereInput!]
  OR: [GovernmentPartySubscriptionWhereInput!]
  NOT: [GovernmentPartySubscriptionWhereInput!]
}

input GovernmentPartyUpdateInput {
  leader: CharacterUpdateOneInput
  name: String
  content: HTMLContentUpdateManyInput
  government: GovernmentUpdateOneWithoutPartiesInput
}

input GovernmentPartyUpdateManyDataInput {
  name: String
}

input GovernmentPartyUpdateManyMutationInput {
  name: String
}

input GovernmentPartyUpdateManyWithoutGovernmentInput {
  create: [GovernmentPartyCreateWithoutGovernmentInput!]
  delete: [GovernmentPartyWhereUniqueInput!]
  connect: [GovernmentPartyWhereUniqueInput!]
  set: [GovernmentPartyWhereUniqueInput!]
  disconnect: [GovernmentPartyWhereUniqueInput!]
  update: [GovernmentPartyUpdateWithWhereUniqueWithoutGovernmentInput!]
  upsert: [GovernmentPartyUpsertWithWhereUniqueWithoutGovernmentInput!]
  deleteMany: [GovernmentPartyScalarWhereInput!]
  updateMany: [GovernmentPartyUpdateManyWithWhereNestedInput!]
}

input GovernmentPartyUpdateManyWithWhereNestedInput {
  where: GovernmentPartyScalarWhereInput!
  data: GovernmentPartyUpdateManyDataInput!
}

input GovernmentPartyUpdateWithoutGovernmentDataInput {
  leader: CharacterUpdateOneInput
  name: String
  content: HTMLContentUpdateManyInput
}

input GovernmentPartyUpdateWithWhereUniqueWithoutGovernmentInput {
  where: GovernmentPartyWhereUniqueInput!
  data: GovernmentPartyUpdateWithoutGovernmentDataInput!
}

input GovernmentPartyUpsertWithWhereUniqueWithoutGovernmentInput {
  where: GovernmentPartyWhereUniqueInput!
  update: GovernmentPartyUpdateWithoutGovernmentDataInput!
  create: GovernmentPartyCreateWithoutGovernmentInput!
}

input GovernmentPartyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  leader: CharacterWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  content_every: HTMLContentWhereInput
  content_some: HTMLContentWhereInput
  content_none: HTMLContentWhereInput
  government: GovernmentWhereInput
  AND: [GovernmentPartyWhereInput!]
  OR: [GovernmentPartyWhereInput!]
  NOT: [GovernmentPartyWhereInput!]
}

input GovernmentPartyWhereUniqueInput {
  id: ID
}

type GovernmentPreviousValues {
  id: ID!
}

type GovernmentSubscriptionPayload {
  mutation: MutationType!
  node: Government
  updatedFields: [String!]
  previousValues: GovernmentPreviousValues
}

input GovernmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GovernmentWhereInput
  AND: [GovernmentSubscriptionWhereInput!]
  OR: [GovernmentSubscriptionWhereInput!]
  NOT: [GovernmentSubscriptionWhereInput!]
}

input GovernmentUpdateDataInput {
  leader: CharacterUpdateOneInput
  parties: GovernmentPartyUpdateManyWithoutGovernmentInput
  content: HTMLContentUpdateManyInput
}

input GovernmentUpdateInput {
  leader: CharacterUpdateOneInput
  parties: GovernmentPartyUpdateManyWithoutGovernmentInput
  content: HTMLContentUpdateManyInput
}

input GovernmentUpdateOneInput {
  create: GovernmentCreateInput
  update: GovernmentUpdateDataInput
  upsert: GovernmentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GovernmentWhereUniqueInput
}

input GovernmentUpdateOneWithoutPartiesInput {
  create: GovernmentCreateWithoutPartiesInput
  update: GovernmentUpdateWithoutPartiesDataInput
  upsert: GovernmentUpsertWithoutPartiesInput
  delete: Boolean
  disconnect: Boolean
  connect: GovernmentWhereUniqueInput
}

input GovernmentUpdateWithoutPartiesDataInput {
  leader: CharacterUpdateOneInput
  content: HTMLContentUpdateManyInput
}

input GovernmentUpsertNestedInput {
  update: GovernmentUpdateDataInput!
  create: GovernmentCreateInput!
}

input GovernmentUpsertWithoutPartiesInput {
  update: GovernmentUpdateWithoutPartiesDataInput!
  create: GovernmentCreateWithoutPartiesInput!
}

input GovernmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  leader: CharacterWhereInput
  parties_every: GovernmentPartyWhereInput
  parties_some: GovernmentPartyWhereInput
  parties_none: GovernmentPartyWhereInput
  content_every: HTMLContentWhereInput
  content_some: HTMLContentWhereInput
  content_none: HTMLContentWhereInput
  AND: [GovernmentWhereInput!]
  OR: [GovernmentWhereInput!]
  NOT: [GovernmentWhereInput!]
}

input GovernmentWhereUniqueInput {
  id: ID
}

type HTMLContent {
  id: ID!
  content: String!
  invisibleTo(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Character!]
}

type HTMLContentConnection {
  pageInfo: PageInfo!
  edges: [HTMLContentEdge]!
  aggregate: AggregateHTMLContent!
}

input HTMLContentCreateInput {
  id: ID
  content: String!
  invisibleTo: CharacterCreateManyInput
}

input HTMLContentCreateManyInput {
  create: [HTMLContentCreateInput!]
  connect: [HTMLContentWhereUniqueInput!]
}

type HTMLContentEdge {
  node: HTMLContent!
  cursor: String!
}

enum HTMLContentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type HTMLContentPreviousValues {
  id: ID!
  content: String!
}

input HTMLContentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [HTMLContentScalarWhereInput!]
  OR: [HTMLContentScalarWhereInput!]
  NOT: [HTMLContentScalarWhereInput!]
}

type HTMLContentSubscriptionPayload {
  mutation: MutationType!
  node: HTMLContent
  updatedFields: [String!]
  previousValues: HTMLContentPreviousValues
}

input HTMLContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HTMLContentWhereInput
  AND: [HTMLContentSubscriptionWhereInput!]
  OR: [HTMLContentSubscriptionWhereInput!]
  NOT: [HTMLContentSubscriptionWhereInput!]
}

input HTMLContentUpdateDataInput {
  content: String
  invisibleTo: CharacterUpdateManyInput
}

input HTMLContentUpdateInput {
  content: String
  invisibleTo: CharacterUpdateManyInput
}

input HTMLContentUpdateManyDataInput {
  content: String
}

input HTMLContentUpdateManyInput {
  create: [HTMLContentCreateInput!]
  update: [HTMLContentUpdateWithWhereUniqueNestedInput!]
  upsert: [HTMLContentUpsertWithWhereUniqueNestedInput!]
  delete: [HTMLContentWhereUniqueInput!]
  connect: [HTMLContentWhereUniqueInput!]
  set: [HTMLContentWhereUniqueInput!]
  disconnect: [HTMLContentWhereUniqueInput!]
  deleteMany: [HTMLContentScalarWhereInput!]
  updateMany: [HTMLContentUpdateManyWithWhereNestedInput!]
}

input HTMLContentUpdateManyMutationInput {
  content: String
}

input HTMLContentUpdateManyWithWhereNestedInput {
  where: HTMLContentScalarWhereInput!
  data: HTMLContentUpdateManyDataInput!
}

input HTMLContentUpdateWithWhereUniqueNestedInput {
  where: HTMLContentWhereUniqueInput!
  data: HTMLContentUpdateDataInput!
}

input HTMLContentUpsertWithWhereUniqueNestedInput {
  where: HTMLContentWhereUniqueInput!
  update: HTMLContentUpdateDataInput!
  create: HTMLContentCreateInput!
}

input HTMLContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  invisibleTo_every: CharacterWhereInput
  invisibleTo_some: CharacterWhereInput
  invisibleTo_none: CharacterWhereInput
  AND: [HTMLContentWhereInput!]
  OR: [HTMLContentWhereInput!]
  NOT: [HTMLContentWhereInput!]
}

input HTMLContentWhereUniqueInput {
  id: ID
}

type Language {
  id: ID!
  name: String!
  script: LANGUAGE_SCRIPT
  location(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
}

enum LANGUAGE_SCRIPT {
  Common
  Dwarvish
  Elvish
  Infernal
  Celestial
  Draconic
  None
}

type LanguageConnection {
  pageInfo: PageInfo!
  edges: [LanguageEdge]!
  aggregate: AggregateLanguage!
}

input LanguageCreateInput {
  id: ID
  name: String!
  script: LANGUAGE_SCRIPT
  location: LocationCreateManyInput
}

input LanguageCreateManyInput {
  create: [LanguageCreateInput!]
  connect: [LanguageWhereUniqueInput!]
}

type LanguageEdge {
  node: Language!
  cursor: String!
}

enum LanguageOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  script_ASC
  script_DESC
}

type LanguagePreviousValues {
  id: ID!
  name: String!
  script: LANGUAGE_SCRIPT
}

input LanguageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  script: LANGUAGE_SCRIPT
  script_not: LANGUAGE_SCRIPT
  script_in: [LANGUAGE_SCRIPT!]
  script_not_in: [LANGUAGE_SCRIPT!]
  AND: [LanguageScalarWhereInput!]
  OR: [LanguageScalarWhereInput!]
  NOT: [LanguageScalarWhereInput!]
}

type LanguageSubscriptionPayload {
  mutation: MutationType!
  node: Language
  updatedFields: [String!]
  previousValues: LanguagePreviousValues
}

input LanguageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LanguageWhereInput
  AND: [LanguageSubscriptionWhereInput!]
  OR: [LanguageSubscriptionWhereInput!]
  NOT: [LanguageSubscriptionWhereInput!]
}

input LanguageUpdateDataInput {
  name: String
  script: LANGUAGE_SCRIPT
  location: LocationUpdateManyInput
}

input LanguageUpdateInput {
  name: String
  script: LANGUAGE_SCRIPT
  location: LocationUpdateManyInput
}

input LanguageUpdateManyDataInput {
  name: String
  script: LANGUAGE_SCRIPT
}

input LanguageUpdateManyInput {
  create: [LanguageCreateInput!]
  update: [LanguageUpdateWithWhereUniqueNestedInput!]
  upsert: [LanguageUpsertWithWhereUniqueNestedInput!]
  delete: [LanguageWhereUniqueInput!]
  connect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  disconnect: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  updateMany: [LanguageUpdateManyWithWhereNestedInput!]
}

input LanguageUpdateManyMutationInput {
  name: String
  script: LANGUAGE_SCRIPT
}

input LanguageUpdateManyWithWhereNestedInput {
  where: LanguageScalarWhereInput!
  data: LanguageUpdateManyDataInput!
}

input LanguageUpdateWithWhereUniqueNestedInput {
  where: LanguageWhereUniqueInput!
  data: LanguageUpdateDataInput!
}

input LanguageUpsertWithWhereUniqueNestedInput {
  where: LanguageWhereUniqueInput!
  update: LanguageUpdateDataInput!
  create: LanguageCreateInput!
}

input LanguageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  script: LANGUAGE_SCRIPT
  script_not: LANGUAGE_SCRIPT
  script_in: [LANGUAGE_SCRIPT!]
  script_not_in: [LANGUAGE_SCRIPT!]
  location_every: LocationWhereInput
  location_some: LocationWhereInput
  location_none: LocationWhereInput
  AND: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
}

input LanguageWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  type: LOCATION_TYPE!
  name: String!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
  metadata: LocationMetaData
  campaign: Campaign!
  parent: ID
}

enum LOCATION_TYPE {
  Village
  City
  BigCity
  Municipality
  Province
  State
  Country
  Continent
  World
  Universe
  Plane
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  type: LOCATION_TYPE!
  name: String!
  locations: LocationCreateManyInput
  metadata: LocationMetaDataCreateOneWithoutLocationInput
  campaign: CampaignCreateOneWithoutLocationsInput!
  parent: ID
}

input LocationCreateManyInput {
  create: [LocationCreateInput!]
  connect: [LocationWhereUniqueInput!]
}

input LocationCreateManyWithoutCampaignInput {
  create: [LocationCreateWithoutCampaignInput!]
  connect: [LocationWhereUniqueInput!]
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input LocationCreateOneWithoutMetadataInput {
  create: LocationCreateWithoutMetadataInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutCampaignInput {
  id: ID
  type: LOCATION_TYPE!
  name: String!
  locations: LocationCreateManyInput
  metadata: LocationMetaDataCreateOneWithoutLocationInput
  parent: ID
}

input LocationCreateWithoutMetadataInput {
  id: ID
  type: LOCATION_TYPE!
  name: String!
  locations: LocationCreateManyInput
  campaign: CampaignCreateOneWithoutLocationsInput!
  parent: ID
}

type LocationEdge {
  node: Location!
  cursor: String!
}

type LocationMetaData {
  id: ID!
  location: Location!
  population: Population
  languages(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Language!]
  religions(where: ReligionWhereInput, orderBy: ReligionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Religion!]
  ethnicities(where: EtnicityWhereInput, orderBy: EtnicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Etnicity!]
  flag(where: FlagWhereInput, orderBy: FlagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Flag!]
  economy: Economy
  government: Government
  weather: WEATHER
  climate: CLIMATE
}

type LocationMetaDataConnection {
  pageInfo: PageInfo!
  edges: [LocationMetaDataEdge]!
  aggregate: AggregateLocationMetaData!
}

input LocationMetaDataCreateInput {
  id: ID
  location: LocationCreateOneWithoutMetadataInput!
  population: PopulationCreateOneInput
  languages: LanguageCreateManyInput
  religions: ReligionCreateManyInput
  ethnicities: EtnicityCreateManyInput
  flag: FlagCreateManyInput
  economy: EconomyCreateOneInput
  government: GovernmentCreateOneInput
  weather: WEATHER
  climate: CLIMATE
}

input LocationMetaDataCreateOneWithoutLocationInput {
  create: LocationMetaDataCreateWithoutLocationInput
  connect: LocationMetaDataWhereUniqueInput
}

input LocationMetaDataCreateWithoutLocationInput {
  id: ID
  population: PopulationCreateOneInput
  languages: LanguageCreateManyInput
  religions: ReligionCreateManyInput
  ethnicities: EtnicityCreateManyInput
  flag: FlagCreateManyInput
  economy: EconomyCreateOneInput
  government: GovernmentCreateOneInput
  weather: WEATHER
  climate: CLIMATE
}

type LocationMetaDataEdge {
  node: LocationMetaData!
  cursor: String!
}

enum LocationMetaDataOrderByInput {
  id_ASC
  id_DESC
  weather_ASC
  weather_DESC
  climate_ASC
  climate_DESC
}

type LocationMetaDataPreviousValues {
  id: ID!
  weather: WEATHER
  climate: CLIMATE
}

type LocationMetaDataSubscriptionPayload {
  mutation: MutationType!
  node: LocationMetaData
  updatedFields: [String!]
  previousValues: LocationMetaDataPreviousValues
}

input LocationMetaDataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationMetaDataWhereInput
  AND: [LocationMetaDataSubscriptionWhereInput!]
  OR: [LocationMetaDataSubscriptionWhereInput!]
  NOT: [LocationMetaDataSubscriptionWhereInput!]
}

input LocationMetaDataUpdateInput {
  location: LocationUpdateOneRequiredWithoutMetadataInput
  population: PopulationUpdateOneInput
  languages: LanguageUpdateManyInput
  religions: ReligionUpdateManyInput
  ethnicities: EtnicityUpdateManyInput
  flag: FlagUpdateManyInput
  economy: EconomyUpdateOneInput
  government: GovernmentUpdateOneInput
  weather: WEATHER
  climate: CLIMATE
}

input LocationMetaDataUpdateManyMutationInput {
  weather: WEATHER
  climate: CLIMATE
}

input LocationMetaDataUpdateOneWithoutLocationInput {
  create: LocationMetaDataCreateWithoutLocationInput
  update: LocationMetaDataUpdateWithoutLocationDataInput
  upsert: LocationMetaDataUpsertWithoutLocationInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationMetaDataWhereUniqueInput
}

input LocationMetaDataUpdateWithoutLocationDataInput {
  population: PopulationUpdateOneInput
  languages: LanguageUpdateManyInput
  religions: ReligionUpdateManyInput
  ethnicities: EtnicityUpdateManyInput
  flag: FlagUpdateManyInput
  economy: EconomyUpdateOneInput
  government: GovernmentUpdateOneInput
  weather: WEATHER
  climate: CLIMATE
}

input LocationMetaDataUpsertWithoutLocationInput {
  update: LocationMetaDataUpdateWithoutLocationDataInput!
  create: LocationMetaDataCreateWithoutLocationInput!
}

input LocationMetaDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: LocationWhereInput
  population: PopulationWhereInput
  languages_every: LanguageWhereInput
  languages_some: LanguageWhereInput
  languages_none: LanguageWhereInput
  religions_every: ReligionWhereInput
  religions_some: ReligionWhereInput
  religions_none: ReligionWhereInput
  ethnicities_every: EtnicityWhereInput
  ethnicities_some: EtnicityWhereInput
  ethnicities_none: EtnicityWhereInput
  flag_every: FlagWhereInput
  flag_some: FlagWhereInput
  flag_none: FlagWhereInput
  economy: EconomyWhereInput
  government: GovernmentWhereInput
  weather: WEATHER
  weather_not: WEATHER
  weather_in: [WEATHER!]
  weather_not_in: [WEATHER!]
  climate: CLIMATE
  climate_not: CLIMATE
  climate_in: [CLIMATE!]
  climate_not_in: [CLIMATE!]
  AND: [LocationMetaDataWhereInput!]
  OR: [LocationMetaDataWhereInput!]
  NOT: [LocationMetaDataWhereInput!]
}

input LocationMetaDataWhereUniqueInput {
  id: ID
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  parent_ASC
  parent_DESC
}

type LocationPreviousValues {
  id: ID!
  type: LOCATION_TYPE!
  name: String!
  parent: ID
}

input LocationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: LOCATION_TYPE
  type_not: LOCATION_TYPE
  type_in: [LOCATION_TYPE!]
  type_not_in: [LOCATION_TYPE!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  parent: ID
  parent_not: ID
  parent_in: [ID!]
  parent_not_in: [ID!]
  parent_lt: ID
  parent_lte: ID
  parent_gt: ID
  parent_gte: ID
  parent_contains: ID
  parent_not_contains: ID
  parent_starts_with: ID
  parent_not_starts_with: ID
  parent_ends_with: ID
  parent_not_ends_with: ID
  AND: [LocationScalarWhereInput!]
  OR: [LocationScalarWhereInput!]
  NOT: [LocationScalarWhereInput!]
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  type: LOCATION_TYPE
  name: String
  locations: LocationUpdateManyInput
  metadata: LocationMetaDataUpdateOneWithoutLocationInput
  campaign: CampaignUpdateOneRequiredWithoutLocationsInput
  parent: ID
}

input LocationUpdateInput {
  type: LOCATION_TYPE
  name: String
  locations: LocationUpdateManyInput
  metadata: LocationMetaDataUpdateOneWithoutLocationInput
  campaign: CampaignUpdateOneRequiredWithoutLocationsInput
  parent: ID
}

input LocationUpdateManyDataInput {
  type: LOCATION_TYPE
  name: String
  parent: ID
}

input LocationUpdateManyInput {
  create: [LocationCreateInput!]
  update: [LocationUpdateWithWhereUniqueNestedInput!]
  upsert: [LocationUpsertWithWhereUniqueNestedInput!]
  delete: [LocationWhereUniqueInput!]
  connect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  disconnect: [LocationWhereUniqueInput!]
  deleteMany: [LocationScalarWhereInput!]
  updateMany: [LocationUpdateManyWithWhereNestedInput!]
}

input LocationUpdateManyMutationInput {
  type: LOCATION_TYPE
  name: String
  parent: ID
}

input LocationUpdateManyWithoutCampaignInput {
  create: [LocationCreateWithoutCampaignInput!]
  delete: [LocationWhereUniqueInput!]
  connect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  disconnect: [LocationWhereUniqueInput!]
  update: [LocationUpdateWithWhereUniqueWithoutCampaignInput!]
  upsert: [LocationUpsertWithWhereUniqueWithoutCampaignInput!]
  deleteMany: [LocationScalarWhereInput!]
  updateMany: [LocationUpdateManyWithWhereNestedInput!]
}

input LocationUpdateManyWithWhereNestedInput {
  where: LocationScalarWhereInput!
  data: LocationUpdateManyDataInput!
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredWithoutMetadataInput {
  create: LocationCreateWithoutMetadataInput
  update: LocationUpdateWithoutMetadataDataInput
  upsert: LocationUpsertWithoutMetadataInput
  connect: LocationWhereUniqueInput
}

input LocationUpdateWithoutCampaignDataInput {
  type: LOCATION_TYPE
  name: String
  locations: LocationUpdateManyInput
  metadata: LocationMetaDataUpdateOneWithoutLocationInput
  parent: ID
}

input LocationUpdateWithoutMetadataDataInput {
  type: LOCATION_TYPE
  name: String
  locations: LocationUpdateManyInput
  campaign: CampaignUpdateOneRequiredWithoutLocationsInput
  parent: ID
}

input LocationUpdateWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput!
  data: LocationUpdateDataInput!
}

input LocationUpdateWithWhereUniqueWithoutCampaignInput {
  where: LocationWhereUniqueInput!
  data: LocationUpdateWithoutCampaignDataInput!
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithoutMetadataInput {
  update: LocationUpdateWithoutMetadataDataInput!
  create: LocationCreateWithoutMetadataInput!
}

input LocationUpsertWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput!
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithWhereUniqueWithoutCampaignInput {
  where: LocationWhereUniqueInput!
  update: LocationUpdateWithoutCampaignDataInput!
  create: LocationCreateWithoutCampaignInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: LOCATION_TYPE
  type_not: LOCATION_TYPE
  type_in: [LOCATION_TYPE!]
  type_not_in: [LOCATION_TYPE!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  locations_every: LocationWhereInput
  locations_some: LocationWhereInput
  locations_none: LocationWhereInput
  metadata: LocationMetaDataWhereInput
  campaign: CampaignWhereInput
  parent: ID
  parent_not: ID
  parent_in: [ID!]
  parent_not_in: [ID!]
  parent_lt: ID
  parent_lte: ID
  parent_gt: ID
  parent_gte: ID
  parent_contains: ID
  parent_not_contains: ID
  parent_starts_with: ID
  parent_not_starts_with: ID
  parent_ends_with: ID
  parent_not_ends_with: ID
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAbility(data: AbilityCreateInput!): Ability!
  updateAbility(data: AbilityUpdateInput!, where: AbilityWhereUniqueInput!): Ability
  updateManyAbilities(data: AbilityUpdateManyMutationInput!, where: AbilityWhereInput): BatchPayload!
  upsertAbility(where: AbilityWhereUniqueInput!, create: AbilityCreateInput!, update: AbilityUpdateInput!): Ability!
  deleteAbility(where: AbilityWhereUniqueInput!): Ability
  deleteManyAbilities(where: AbilityWhereInput): BatchPayload!
  createCampaign(data: CampaignCreateInput!): Campaign!
  updateCampaign(data: CampaignUpdateInput!, where: CampaignWhereUniqueInput!): Campaign
  updateManyCampaigns(data: CampaignUpdateManyMutationInput!, where: CampaignWhereInput): BatchPayload!
  upsertCampaign(where: CampaignWhereUniqueInput!, create: CampaignCreateInput!, update: CampaignUpdateInput!): Campaign!
  deleteCampaign(where: CampaignWhereUniqueInput!): Campaign
  deleteManyCampaigns(where: CampaignWhereInput): BatchPayload!
  createCharacter(data: CharacterCreateInput!): Character!
  updateCharacter(data: CharacterUpdateInput!, where: CharacterWhereUniqueInput!): Character
  updateManyCharacters(data: CharacterUpdateManyMutationInput!, where: CharacterWhereInput): BatchPayload!
  upsertCharacter(where: CharacterWhereUniqueInput!, create: CharacterCreateInput!, update: CharacterUpdateInput!): Character!
  deleteCharacter(where: CharacterWhereUniqueInput!): Character
  deleteManyCharacters(where: CharacterWhereInput): BatchPayload!
  createCharacterMetadata(data: CharacterMetadataCreateInput!): CharacterMetadata!
  updateCharacterMetadata(data: CharacterMetadataUpdateInput!, where: CharacterMetadataWhereUniqueInput!): CharacterMetadata
  updateManyCharacterMetadatas(data: CharacterMetadataUpdateManyMutationInput!, where: CharacterMetadataWhereInput): BatchPayload!
  upsertCharacterMetadata(where: CharacterMetadataWhereUniqueInput!, create: CharacterMetadataCreateInput!, update: CharacterMetadataUpdateInput!): CharacterMetadata!
  deleteCharacterMetadata(where: CharacterMetadataWhereUniqueInput!): CharacterMetadata
  deleteManyCharacterMetadatas(where: CharacterMetadataWhereInput): BatchPayload!
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  updateManyCurrencies(data: CurrencyUpdateManyMutationInput!, where: CurrencyWhereInput): BatchPayload!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
  createEconomy(data: EconomyCreateInput!): Economy!
  updateEconomy(data: EconomyUpdateInput!, where: EconomyWhereUniqueInput!): Economy
  upsertEconomy(where: EconomyWhereUniqueInput!, create: EconomyCreateInput!, update: EconomyUpdateInput!): Economy!
  deleteEconomy(where: EconomyWhereUniqueInput!): Economy
  deleteManyEconomies(where: EconomyWhereInput): BatchPayload!
  createEtnicity(data: EtnicityCreateInput!): Etnicity!
  updateEtnicity(data: EtnicityUpdateInput!, where: EtnicityWhereUniqueInput!): Etnicity
  updateManyEtnicities(data: EtnicityUpdateManyMutationInput!, where: EtnicityWhereInput): BatchPayload!
  upsertEtnicity(where: EtnicityWhereUniqueInput!, create: EtnicityCreateInput!, update: EtnicityUpdateInput!): Etnicity!
  deleteEtnicity(where: EtnicityWhereUniqueInput!): Etnicity
  deleteManyEtnicities(where: EtnicityWhereInput): BatchPayload!
  createFlag(data: FlagCreateInput!): Flag!
  updateFlag(data: FlagUpdateInput!, where: FlagWhereUniqueInput!): Flag
  updateManyFlags(data: FlagUpdateManyMutationInput!, where: FlagWhereInput): BatchPayload!
  upsertFlag(where: FlagWhereUniqueInput!, create: FlagCreateInput!, update: FlagUpdateInput!): Flag!
  deleteFlag(where: FlagWhereUniqueInput!): Flag
  deleteManyFlags(where: FlagWhereInput): BatchPayload!
  createGovernment(data: GovernmentCreateInput!): Government!
  updateGovernment(data: GovernmentUpdateInput!, where: GovernmentWhereUniqueInput!): Government
  upsertGovernment(where: GovernmentWhereUniqueInput!, create: GovernmentCreateInput!, update: GovernmentUpdateInput!): Government!
  deleteGovernment(where: GovernmentWhereUniqueInput!): Government
  deleteManyGovernments(where: GovernmentWhereInput): BatchPayload!
  createGovernmentParty(data: GovernmentPartyCreateInput!): GovernmentParty!
  updateGovernmentParty(data: GovernmentPartyUpdateInput!, where: GovernmentPartyWhereUniqueInput!): GovernmentParty
  updateManyGovernmentParties(data: GovernmentPartyUpdateManyMutationInput!, where: GovernmentPartyWhereInput): BatchPayload!
  upsertGovernmentParty(where: GovernmentPartyWhereUniqueInput!, create: GovernmentPartyCreateInput!, update: GovernmentPartyUpdateInput!): GovernmentParty!
  deleteGovernmentParty(where: GovernmentPartyWhereUniqueInput!): GovernmentParty
  deleteManyGovernmentParties(where: GovernmentPartyWhereInput): BatchPayload!
  createHTMLContent(data: HTMLContentCreateInput!): HTMLContent!
  updateHTMLContent(data: HTMLContentUpdateInput!, where: HTMLContentWhereUniqueInput!): HTMLContent
  updateManyHTMLContents(data: HTMLContentUpdateManyMutationInput!, where: HTMLContentWhereInput): BatchPayload!
  upsertHTMLContent(where: HTMLContentWhereUniqueInput!, create: HTMLContentCreateInput!, update: HTMLContentUpdateInput!): HTMLContent!
  deleteHTMLContent(where: HTMLContentWhereUniqueInput!): HTMLContent
  deleteManyHTMLContents(where: HTMLContentWhereInput): BatchPayload!
  createLanguage(data: LanguageCreateInput!): Language!
  updateLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateManyLanguages(data: LanguageUpdateManyMutationInput!, where: LanguageWhereInput): BatchPayload!
  upsertLanguage(where: LanguageWhereUniqueInput!, create: LanguageCreateInput!, update: LanguageUpdateInput!): Language!
  deleteLanguage(where: LanguageWhereUniqueInput!): Language
  deleteManyLanguages(where: LanguageWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createLocationMetaData(data: LocationMetaDataCreateInput!): LocationMetaData!
  updateLocationMetaData(data: LocationMetaDataUpdateInput!, where: LocationMetaDataWhereUniqueInput!): LocationMetaData
  updateManyLocationMetaDatas(data: LocationMetaDataUpdateManyMutationInput!, where: LocationMetaDataWhereInput): BatchPayload!
  upsertLocationMetaData(where: LocationMetaDataWhereUniqueInput!, create: LocationMetaDataCreateInput!, update: LocationMetaDataUpdateInput!): LocationMetaData!
  deleteLocationMetaData(where: LocationMetaDataWhereUniqueInput!): LocationMetaData
  deleteManyLocationMetaDatas(where: LocationMetaDataWhereInput): BatchPayload!
  createPopulation(data: PopulationCreateInput!): Population!
  updatePopulation(data: PopulationUpdateInput!, where: PopulationWhereUniqueInput!): Population
  updateManyPopulations(data: PopulationUpdateManyMutationInput!, where: PopulationWhereInput): BatchPayload!
  upsertPopulation(where: PopulationWhereUniqueInput!, create: PopulationCreateInput!, update: PopulationUpdateInput!): Population!
  deletePopulation(where: PopulationWhereUniqueInput!): Population
  deleteManyPopulations(where: PopulationWhereInput): BatchPayload!
  createReligion(data: ReligionCreateInput!): Religion!
  updateReligion(data: ReligionUpdateInput!, where: ReligionWhereUniqueInput!): Religion
  updateManyReligions(data: ReligionUpdateManyMutationInput!, where: ReligionWhereInput): BatchPayload!
  upsertReligion(where: ReligionWhereUniqueInput!, create: ReligionCreateInput!, update: ReligionUpdateInput!): Religion!
  deleteReligion(where: ReligionWhereUniqueInput!): Religion
  deleteManyReligions(where: ReligionWhereInput): BatchPayload!
  createSkill(data: SkillCreateInput!): Skill!
  updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateManySkills(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): BatchPayload!
  upsertSkill(where: SkillWhereUniqueInput!, create: SkillCreateInput!, update: SkillUpdateInput!): Skill!
  deleteSkill(where: SkillWhereUniqueInput!): Skill
  deleteManySkills(where: SkillWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Population {
  id: ID!
  location: Location!
  inhabitants: Int!
  density: Int!
  densityUnit: DENSITY_UNIT!
}

type PopulationConnection {
  pageInfo: PageInfo!
  edges: [PopulationEdge]!
  aggregate: AggregatePopulation!
}

input PopulationCreateInput {
  id: ID
  location: LocationCreateOneInput!
  inhabitants: Int!
  density: Int!
  densityUnit: DENSITY_UNIT!
}

input PopulationCreateOneInput {
  create: PopulationCreateInput
  connect: PopulationWhereUniqueInput
}

type PopulationEdge {
  node: Population!
  cursor: String!
}

enum PopulationOrderByInput {
  id_ASC
  id_DESC
  inhabitants_ASC
  inhabitants_DESC
  density_ASC
  density_DESC
  densityUnit_ASC
  densityUnit_DESC
}

type PopulationPreviousValues {
  id: ID!
  inhabitants: Int!
  density: Int!
  densityUnit: DENSITY_UNIT!
}

type PopulationSubscriptionPayload {
  mutation: MutationType!
  node: Population
  updatedFields: [String!]
  previousValues: PopulationPreviousValues
}

input PopulationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PopulationWhereInput
  AND: [PopulationSubscriptionWhereInput!]
  OR: [PopulationSubscriptionWhereInput!]
  NOT: [PopulationSubscriptionWhereInput!]
}

input PopulationUpdateDataInput {
  location: LocationUpdateOneRequiredInput
  inhabitants: Int
  density: Int
  densityUnit: DENSITY_UNIT
}

input PopulationUpdateInput {
  location: LocationUpdateOneRequiredInput
  inhabitants: Int
  density: Int
  densityUnit: DENSITY_UNIT
}

input PopulationUpdateManyMutationInput {
  inhabitants: Int
  density: Int
  densityUnit: DENSITY_UNIT
}

input PopulationUpdateOneInput {
  create: PopulationCreateInput
  update: PopulationUpdateDataInput
  upsert: PopulationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PopulationWhereUniqueInput
}

input PopulationUpsertNestedInput {
  update: PopulationUpdateDataInput!
  create: PopulationCreateInput!
}

input PopulationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: LocationWhereInput
  inhabitants: Int
  inhabitants_not: Int
  inhabitants_in: [Int!]
  inhabitants_not_in: [Int!]
  inhabitants_lt: Int
  inhabitants_lte: Int
  inhabitants_gt: Int
  inhabitants_gte: Int
  density: Int
  density_not: Int
  density_in: [Int!]
  density_not_in: [Int!]
  density_lt: Int
  density_lte: Int
  density_gt: Int
  density_gte: Int
  densityUnit: DENSITY_UNIT
  densityUnit_not: DENSITY_UNIT
  densityUnit_in: [DENSITY_UNIT!]
  densityUnit_not_in: [DENSITY_UNIT!]
  AND: [PopulationWhereInput!]
  OR: [PopulationWhereInput!]
  NOT: [PopulationWhereInput!]
}

input PopulationWhereUniqueInput {
  id: ID
}

type Query {
  ability(where: AbilityWhereUniqueInput!): Ability
  abilities(where: AbilityWhereInput, orderBy: AbilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ability]!
  abilitiesConnection(where: AbilityWhereInput, orderBy: AbilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AbilityConnection!
  campaign(where: CampaignWhereUniqueInput!): Campaign
  campaigns(where: CampaignWhereInput, orderBy: CampaignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Campaign]!
  campaignsConnection(where: CampaignWhereInput, orderBy: CampaignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CampaignConnection!
  character(where: CharacterWhereUniqueInput!): Character
  characters(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Character]!
  charactersConnection(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CharacterConnection!
  characterMetadata(where: CharacterMetadataWhereUniqueInput!): CharacterMetadata
  characterMetadatas(where: CharacterMetadataWhereInput, orderBy: CharacterMetadataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CharacterMetadata]!
  characterMetadatasConnection(where: CharacterMetadataWhereInput, orderBy: CharacterMetadataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CharacterMetadataConnection!
  currency(where: CurrencyWhereUniqueInput!): Currency
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!
  economy(where: EconomyWhereUniqueInput!): Economy
  economies(where: EconomyWhereInput, orderBy: EconomyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Economy]!
  economiesConnection(where: EconomyWhereInput, orderBy: EconomyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EconomyConnection!
  etnicity(where: EtnicityWhereUniqueInput!): Etnicity
  etnicities(where: EtnicityWhereInput, orderBy: EtnicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Etnicity]!
  etnicitiesConnection(where: EtnicityWhereInput, orderBy: EtnicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EtnicityConnection!
  flag(where: FlagWhereUniqueInput!): Flag
  flags(where: FlagWhereInput, orderBy: FlagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Flag]!
  flagsConnection(where: FlagWhereInput, orderBy: FlagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FlagConnection!
  government(where: GovernmentWhereUniqueInput!): Government
  governments(where: GovernmentWhereInput, orderBy: GovernmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Government]!
  governmentsConnection(where: GovernmentWhereInput, orderBy: GovernmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GovernmentConnection!
  governmentParty(where: GovernmentPartyWhereUniqueInput!): GovernmentParty
  governmentParties(where: GovernmentPartyWhereInput, orderBy: GovernmentPartyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GovernmentParty]!
  governmentPartiesConnection(where: GovernmentPartyWhereInput, orderBy: GovernmentPartyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GovernmentPartyConnection!
  hTMLContent(where: HTMLContentWhereUniqueInput!): HTMLContent
  hTMLContents(where: HTMLContentWhereInput, orderBy: HTMLContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HTMLContent]!
  hTMLContentsConnection(where: HTMLContentWhereInput, orderBy: HTMLContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HTMLContentConnection!
  language(where: LanguageWhereUniqueInput!): Language
  languages(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Language]!
  languagesConnection(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LanguageConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  locationMetaData(where: LocationMetaDataWhereUniqueInput!): LocationMetaData
  locationMetaDatas(where: LocationMetaDataWhereInput, orderBy: LocationMetaDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LocationMetaData]!
  locationMetaDatasConnection(where: LocationMetaDataWhereInput, orderBy: LocationMetaDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationMetaDataConnection!
  population(where: PopulationWhereUniqueInput!): Population
  populations(where: PopulationWhereInput, orderBy: PopulationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Population]!
  populationsConnection(where: PopulationWhereInput, orderBy: PopulationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PopulationConnection!
  religion(where: ReligionWhereUniqueInput!): Religion
  religions(where: ReligionWhereInput, orderBy: ReligionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Religion]!
  religionsConnection(where: ReligionWhereInput, orderBy: ReligionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReligionConnection!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill]!
  skillsConnection(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkillConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum RACE {
  Dragonborn
  Dwarf
  Elf
  Gnome
  HalfElf
  HalfOrc
  Halfling
  Human
  Tiefling
}

type Religion {
  id: ID!
  name: String!
  deity: Character
  content(where: HTMLContentWhereInput, orderBy: HTMLContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HTMLContent!]
  location: Location
}

type ReligionConnection {
  pageInfo: PageInfo!
  edges: [ReligionEdge]!
  aggregate: AggregateReligion!
}

input ReligionCreateInput {
  id: ID
  name: String!
  deity: CharacterCreateOneInput
  content: HTMLContentCreateManyInput
  location: LocationCreateOneInput
}

input ReligionCreateManyInput {
  create: [ReligionCreateInput!]
  connect: [ReligionWhereUniqueInput!]
}

type ReligionEdge {
  node: Religion!
  cursor: String!
}

enum ReligionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ReligionPreviousValues {
  id: ID!
  name: String!
}

input ReligionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ReligionScalarWhereInput!]
  OR: [ReligionScalarWhereInput!]
  NOT: [ReligionScalarWhereInput!]
}

type ReligionSubscriptionPayload {
  mutation: MutationType!
  node: Religion
  updatedFields: [String!]
  previousValues: ReligionPreviousValues
}

input ReligionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReligionWhereInput
  AND: [ReligionSubscriptionWhereInput!]
  OR: [ReligionSubscriptionWhereInput!]
  NOT: [ReligionSubscriptionWhereInput!]
}

input ReligionUpdateDataInput {
  name: String
  deity: CharacterUpdateOneInput
  content: HTMLContentUpdateManyInput
  location: LocationUpdateOneInput
}

input ReligionUpdateInput {
  name: String
  deity: CharacterUpdateOneInput
  content: HTMLContentUpdateManyInput
  location: LocationUpdateOneInput
}

input ReligionUpdateManyDataInput {
  name: String
}

input ReligionUpdateManyInput {
  create: [ReligionCreateInput!]
  update: [ReligionUpdateWithWhereUniqueNestedInput!]
  upsert: [ReligionUpsertWithWhereUniqueNestedInput!]
  delete: [ReligionWhereUniqueInput!]
  connect: [ReligionWhereUniqueInput!]
  set: [ReligionWhereUniqueInput!]
  disconnect: [ReligionWhereUniqueInput!]
  deleteMany: [ReligionScalarWhereInput!]
  updateMany: [ReligionUpdateManyWithWhereNestedInput!]
}

input ReligionUpdateManyMutationInput {
  name: String
}

input ReligionUpdateManyWithWhereNestedInput {
  where: ReligionScalarWhereInput!
  data: ReligionUpdateManyDataInput!
}

input ReligionUpdateWithWhereUniqueNestedInput {
  where: ReligionWhereUniqueInput!
  data: ReligionUpdateDataInput!
}

input ReligionUpsertWithWhereUniqueNestedInput {
  where: ReligionWhereUniqueInput!
  update: ReligionUpdateDataInput!
  create: ReligionCreateInput!
}

input ReligionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  deity: CharacterWhereInput
  content_every: HTMLContentWhereInput
  content_some: HTMLContentWhereInput
  content_none: HTMLContentWhereInput
  location: LocationWhereInput
  AND: [ReligionWhereInput!]
  OR: [ReligionWhereInput!]
  NOT: [ReligionWhereInput!]
}

input ReligionWhereUniqueInput {
  id: ID
}

enum ROLE {
  PLAYER
  ADMIN
}

type Skill {
  id: ID!
  name: SKILL!
  value: Int!
  character: Character!
}

enum SKILL {
  Acrobatics
  AnimalHandling
  Arcana
  Athletics
  Deception
  History
  Insight
  Intimidation
  Investigation
  Medicine
  Nature
  Perception
  Performance
  Persuasion
  Religion
  SleightOfHand
  Stealth
  Survival
}

type SkillConnection {
  pageInfo: PageInfo!
  edges: [SkillEdge]!
  aggregate: AggregateSkill!
}

input SkillCreateInput {
  id: ID
  name: SKILL!
  value: Int!
  character: CharacterCreateOneInput!
}

input SkillCreateManyInput {
  create: [SkillCreateInput!]
  connect: [SkillWhereUniqueInput!]
}

type SkillEdge {
  node: Skill!
  cursor: String!
}

enum SkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  value_ASC
  value_DESC
}

type SkillPreviousValues {
  id: ID!
  name: SKILL!
  value: Int!
}

input SkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: SKILL
  name_not: SKILL
  name_in: [SKILL!]
  name_not_in: [SKILL!]
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  AND: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
  NOT: [SkillScalarWhereInput!]
}

type SkillSubscriptionPayload {
  mutation: MutationType!
  node: Skill
  updatedFields: [String!]
  previousValues: SkillPreviousValues
}

input SkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkillWhereInput
  AND: [SkillSubscriptionWhereInput!]
  OR: [SkillSubscriptionWhereInput!]
  NOT: [SkillSubscriptionWhereInput!]
}

input SkillUpdateDataInput {
  name: SKILL
  value: Int
  character: CharacterUpdateOneRequiredInput
}

input SkillUpdateInput {
  name: SKILL
  value: Int
  character: CharacterUpdateOneRequiredInput
}

input SkillUpdateManyDataInput {
  name: SKILL
  value: Int
}

input SkillUpdateManyInput {
  create: [SkillCreateInput!]
  update: [SkillUpdateWithWhereUniqueNestedInput!]
  upsert: [SkillUpsertWithWhereUniqueNestedInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyMutationInput {
  name: SKILL
  value: Int
}

input SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput!
  data: SkillUpdateManyDataInput!
}

input SkillUpdateWithWhereUniqueNestedInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateDataInput!
}

input SkillUpsertWithWhereUniqueNestedInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateDataInput!
  create: SkillCreateInput!
}

input SkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: SKILL
  name_not: SKILL
  name_in: [SKILL!]
  name_not_in: [SKILL!]
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  character: CharacterWhereInput
  AND: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
}

type Subscription {
  ability(where: AbilitySubscriptionWhereInput): AbilitySubscriptionPayload
  campaign(where: CampaignSubscriptionWhereInput): CampaignSubscriptionPayload
  character(where: CharacterSubscriptionWhereInput): CharacterSubscriptionPayload
  characterMetadata(where: CharacterMetadataSubscriptionWhereInput): CharacterMetadataSubscriptionPayload
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
  economy(where: EconomySubscriptionWhereInput): EconomySubscriptionPayload
  etnicity(where: EtnicitySubscriptionWhereInput): EtnicitySubscriptionPayload
  flag(where: FlagSubscriptionWhereInput): FlagSubscriptionPayload
  government(where: GovernmentSubscriptionWhereInput): GovernmentSubscriptionPayload
  governmentParty(where: GovernmentPartySubscriptionWhereInput): GovernmentPartySubscriptionPayload
  hTMLContent(where: HTMLContentSubscriptionWhereInput): HTMLContentSubscriptionPayload
  language(where: LanguageSubscriptionWhereInput): LanguageSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  locationMetaData(where: LocationMetaDataSubscriptionWhereInput): LocationMetaDataSubscriptionPayload
  population(where: PopulationSubscriptionWhereInput): PopulationSubscriptionPayload
  religion(where: ReligionSubscriptionWhereInput): ReligionSubscriptionPayload
  skill(where: SkillSubscriptionWhereInput): SkillSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  role: ROLE!
  campaigns(where: CampaignWhereInput, orderBy: CampaignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Campaign!]
  firstName: String
  lastName: String
  characters(where: CharacterWhereInput, orderBy: CharacterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Character!]
  resetToken: String
  resetTokenExpiry: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  role: ROLE
  campaigns: CampaignCreateManyInput
  firstName: String
  lastName: String
  characters: CharacterCreateManyInput
  resetToken: String
  resetTokenExpiry: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  role: ROLE!
  firstName: String
  lastName: String
  resetToken: String
  resetTokenExpiry: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  role: ROLE
  campaigns: CampaignUpdateManyInput
  firstName: String
  lastName: String
  characters: CharacterUpdateManyInput
  resetToken: String
  resetTokenExpiry: String
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  role: ROLE
  firstName: String
  lastName: String
  resetToken: String
  resetTokenExpiry: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: ROLE
  role_not: ROLE
  role_in: [ROLE!]
  role_not_in: [ROLE!]
  campaigns_every: CampaignWhereInput
  campaigns_some: CampaignWhereInput
  campaigns_none: CampaignWhereInput
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  characters_every: CharacterWhereInput
  characters_some: CharacterWhereInput
  characters_none: CharacterWhereInput
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: String
  resetTokenExpiry_not: String
  resetTokenExpiry_in: [String!]
  resetTokenExpiry_not_in: [String!]
  resetTokenExpiry_lt: String
  resetTokenExpiry_lte: String
  resetTokenExpiry_gt: String
  resetTokenExpiry_gte: String
  resetTokenExpiry_contains: String
  resetTokenExpiry_not_contains: String
  resetTokenExpiry_starts_with: String
  resetTokenExpiry_not_starts_with: String
  resetTokenExpiry_ends_with: String
  resetTokenExpiry_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

enum WEATHER {
  Wind
  Sun
  Cloudy
  Snow
}
